package main

import (
	"flag"
	"fmt"
	"math/rand"
	mylog "mylog2"
	"os"
	"time"
	"xchain-go/common"
	"xchain-go/core"
	"xchain-go/core/basic"
	"xchain-go/p2p"
)

var prefix = "main"

func log(prefix string) *mylog.SimpleLogger {
	common.InitLog(prefix)
	return common.Logger.NewSessionLogger()
}

//负责处理命令行参数的CLI
type CLI struct {
	//对象是链
	bc *core.BlockChain
}

//方法说明
func (cli *CLI) printusage() {
	fmt.Println("usage:")
	fmt.Println(" ./xchain createDB                          -- create a database")
	fmt.Println(" ./xchain createBlockchain                  -- init a blockchain")
	fmt.Println(" ./xchain printblockchain                   -- print all block in the blockchain")
	fmt.Println(" ./xchain startServer                       -- start the blockchain")
	fmt.Println(" ./xchain addblock -data 'Block data'       -- add a new block into the blockchain")

}

//新建一个leveldb
func (cli *CLI) CreateLDB(name string, cache, handles int) {
	Log := log(prefix)
	Log.Infoln("CreateLDB cache and file handles,", "cache: ", cache, "handles: ", handles)
	cli.bc.DB, _ = basic.OpenDatabase(name, cache, handles)
	Log.Infoln("创建数据库成功")

}

//初始化区块链
func (cli *CLI) createBlockchain() {
	Log := log(prefix)
	bc := core.NewBlockchain()
	Log.Infoln("创建区块链成功，链信息为:", bc)
}

//添加区块
func (cli *CLI) addBlock(extradata string) {
	header := &basic.Header{}
	body := &basic.Body{}
	header.Extradata = []byte(extradata)
	cli.bc.AddBlock(header, body)
}

//打印区块链内容
func (cli *CLI) printblockchain() {
	cli.bc.PrintBlockchain()
}

//启动dpos的链
func (cli *CLI) startServer() {
	Log := log(prefix)

	//开启监听服务
	go func() {
		p2p.UdpListen()
	}()

	CreateNode()
	Log.Infoln(NodeArr)
	Vote()
	nodes := SortNodes()
	Log.Infoln(nodes)
	//初始化一条链

	// 添加区块
	nodesNum := len(nodes)
	for i := 0; i < nodesNum; i++ {

		// 构造区块
		header := &basic.Header{}
		// header2 := &Header{}
		body := &basic.Body{}
		// body2 := &Body{}
		header.Extradata = []byte("sender 1btc to alice")
		header.Validator = nodes[i].Name
		cli.bc.AddBlock(header, body)
		p2p.UdpDial()
		time.Sleep(time.Second)

	}

	cli.printblockchain()

}

//校验输入的参数是否合法
//如果参数的长度小于2，即参数中只有二进制项目名，没有后面相应的执行的命令及参数，则退出
func (cli *CLI) validateArgs() {
	if len(os.Args) < 2 {
		// Log.Infoln(os.Args[:])
		cli.printusage()
		os.Exit(1)
	}
	// Log.Infoln(os.Args[:])
}

func (cli *CLI) Run() {
	Log := log(prefix)

	cli.validateArgs()
	//flag命令进行定义
	printusageCmd := flag.NewFlagSet("printusage", flag.ExitOnError)             //打印用法
	printBlockchainCmd := flag.NewFlagSet("printblockchain", flag.ExitOnError)   //打印区块链
	addblockCmd := flag.NewFlagSet("addblock", flag.ExitOnError)                 //添加区块
	addblockData := addblockCmd.String("data", "", "Block ExtraData")            //addblockData定义一个string的flag,来对data的参数进行判断。得到的是一个指针对象
	startServerCmd := flag.NewFlagSet("startServer", flag.ExitOnError)           //启动区块链进行投票出块
	createBlockchainCmd := flag.NewFlagSet("createblockchain", flag.ExitOnError) //初始化一条区块链
	createDBCmd := flag.NewFlagSet("createDB", flag.ExitOnError)                 //创建一个db
	// createDBName := createDBCmd.String("name", "", "DB name,string类型")           //createDBName,创建的db name
	// createDBCache := createDBCmd.String("cache", "", "DB cache,int类型")           //createDBCache,创建的db cache
	// createDBHandles := createDBCmd.String("handles", "", "DB handles,int类型")     //createDBHandles,创建的db handles

	//判断传入的命令参数内容
	//参数内容中，第一个字符为二进制项目名，第二个字符开始内容为实际的输入。
	//第二个字符为实际想执行的命令字段，第三个字符为要传入的参数
	//判断第二个参数的内容，来执行printblockchain、addblock、printusage的对应操作
	switch os.Args[1] {
	case "printusage":
		err := printusageCmd.Parse(os.Args[2:])
		if err != nil {
			Log.Infoln(err)
		}

	case "printblockchain":
		err := printBlockchainCmd.Parse(os.Args[2:])
		if err != nil {
			Log.Infoln(err)
		}

	case "addblock":
		err := addblockCmd.Parse(os.Args[2:])
		if err != nil {
			Log.Infoln(err)
		}

	case "startServer":
		err := startServerCmd.Parse(os.Args[2:])
		if err != nil {
			Log.Infoln(err)
		}
	case "createBlockchain":
		err := createBlockchainCmd.Parse(os.Args[2:])
		if err != nil {
			Log.Infoln(err)
		}
	case "createDB":
		err := createDBCmd.Parse(os.Args[2:])
		if err != nil {
			Log.Infoln(err)
		}
	default:
		//非零为错误退出
		cli.printusage()
		os.Exit(1)
	}

	//初始化启动的时候，打印usage
	if printusageCmd.Parsed() {
		cli.printusage()
	}
	//创建数据库
	if createDBCmd.Parsed() {
		// //读取name
		// if *createDBName == "" {
		// 	cli.printusage()
		// 	os.Exit(1)
		// }
		// name := *createDBName
		// //读取cache和handles数量
		// if *createDBCache == "" {
		// 	cli.printusage()
		// 	os.Exit(1)
		// }
		// cache, _ := strconv.Atoi(*createDBCache)
		// if *createDBHandles == "" {
		// 	cli.printusage()
		// 	os.Exit(1)
		// }
		// handles, _ := strconv.Atoi(*createDBHandles)
		// cli.CreateLDB(name, cache, handles)
		cli.CreateLDB(dbFile, 512, 512)

	}

	//命令行信息读取结束，则执行打印区块链的操作
	//todo:完成数据持久化后，从数据库读取链的所有内容
	if printBlockchainCmd.Parsed() {
		cli.printblockchain()
	}

	//判断addblock命令传入的参数，添加新区块
	//todo：完成数据持久化后，将添加的块插入数据库
	if addblockCmd.Parsed() {
		//判断输入的data参数的值是否为空
		if *addblockData == "" {
			// Log.Infoln(*addblockData)
			cli.printusage()
			os.Exit(1)
		}
		Log.Infoln(*addblockData)
		cli.addBlock(*addblockData)
		// cli.printblockchain()
	}

	if startServerCmd.Parsed() {
		cli.startServer()
	}
	if createBlockchainCmd.Parsed() {
		cli.createBlockchain()
	}

}

// 创建节点
func CreateNode() {
	for i := 0; i < 10; i++ {
		name := RandStringBytes(basic.AddressLength)
		NodeArr[i] = Node{name, 0}
	}
}

func RandStringBytes(n int) common.Address {
	letterBytes := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	var b common.Address
	for i := range b {
		b[i] = letterBytes[rand.Intn(len(letterBytes))]
	}
	return b
}

//简单模拟投票
func Vote() {
	for i := 0; i < 10; i++ {
		rand.Seed(time.Now().UnixNano())
		vote := rand.Intn(10) + 1
		NodeArr[i].Votes = vote
	}
}

//选出票数最多的前3位
func SortNodes() []Node {
	n := NodeArr
	for i := 0; i < len(n); i++ {
		for j := 0; j < len(n)-1; j++ {
			if n[j].Votes < n[j+1].Votes {
				n[j], n[j+1] = n[j+1], n[j]
			}
		}
	}
	return n[:3]
}
