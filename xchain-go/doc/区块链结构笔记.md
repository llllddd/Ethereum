# 写一条基于账户模型的链
[blockchain_go](https://jeiwan.cc/)
[Go语言编写一个小型区块链](https://www.jianshu.com/p/a10c94cd5952)



先定义块和链的基础结构，目前不包含交易、账户等信息。

---
## *block
---
`block.go`
包含的功能：
**1. block的数据结构(包括header,和body的数据结构)**
- **block结构**包括：*Header,*Body
- **Header结构**包括：父hash(ParentHash)、产生块的节点的地址(Coinbase)、区块产生的时间戳(Timestamp)、区块hash(Blockhash)、区块号(Number)、额外信息(Extradata)
- **Body结构**包括：预留字段。第一版还没有包含交易等信息进去。

**2. 计算block的hash方法-`SetHash`**
- **组装的参数**：ParentHash，Timestamp，Number，Extradata
-  将block中的已有字段的string类型数据拼接起来，转为byte，通过keccak256算法`crypto.Keccak256Hash`得到Hash

**3. 创建新区块函数-`NewBlock`**
- 参数:传入header和body
- 组装区块
- 计算当前块生成的时间戳
- 计算块的hash，返回block

**4. 创建genesisblock函数-`NewGenesisBlock`**
- 第一版先定义一个块为创世块。内容先在方法里设置好
- 返回block
### 1. block的数据结构(包括header,和body的数据结构)
---
```
type Header struct {
	ParentHash string //父hash
	Coinbase   []byte //miner
	Timestamp  int64  //区块产生的时间戳
	Blockhash  string //区块hash
	Number     int    //区块号
	Extradata  []byte //额外信息
	//todo:difficulty\gaslimit\gasused\nonce\totaldifficulty
	//todo:uncle\stateroot\Txhash\receipthash\bloom\
}

//body先预留一个字段
type Body struct {
	body []byte
}
type Block struct {
	header *Header
	// transactions Transactions
	body *Body
}

```
### 2. 计算block的hash方法-`SetHash`
---
将block中的已有字段拼接起来，转为byte，通过keccak256算法得到Hash值
```
//计算Blockhash
//将block中的已有字段拼接起来，转为byte，通过keccak256算法得到Hash值
//组装的参数为每个参数的string类型：ParentHash，Timestamp，Number，Extradata
func (block *Block) SetHash() string {
	header := block.header
	record := string(header.Extradata) + strconv.FormatInt(header.Timestamp, 10) + strconv.Itoa(header.Number) + header.ParentHash
	recordbyte := []byte(record)
	h := crypto.Keccak256Hash(recordbyte).String() //转为commonhash
	return h
}
```
### 3. 创建新区块函数-`NewBlock`
---
```
//生成新区块
//TODO：body中的tx等作为参数传入
func NewBlock(header *Header, body *Body) *Block {
	b := &Block{header: CopyHeader(header), body: body}
	b.header.Timestamp = time.Now().Unix()
	_,b.header.Blockhash = b.SetHash()
	return b
}
```
### 4. 创建genesisblock函数-`NewGenesisBlock`
---
```
//genesisblock
//todo，通过文件形式传入genesisblock
func NewGenesisBlock() *Block {
	header := &Header{}
	body := &Body{}
	b := &Block{header: header, body: body}
	b.header.Extradata = []byte("Genesis Block")
	b.header.Coinbase = nil
	b.header.Number = 0
	b.header.ParentHash = nil
	b.header.Timestamp = 1535706356
	_,b.header.Blockhash = b.SetHash()
	Logger.Infoln("block", b)

	return b
}
```
###  5. 处理header函数
---
```
//处理header,防止修改头变量出现其他影响

func CopyHeader(header *Header) *Header {
	copyhead := *header
	if len(copyhead.Extradata) > 0 {
		copyhead.Extradata = make([]byte, len(header.Extradata))
		copy(copyhead.Extradata, header.Extradata)
	}
	return &copyhead
}
```
---
## *blockchain
---
定义完区块的一些基础结构，可以开始定义基础链中的一些信息
`blockchain.go`
包含的功能：
**1. blockchain的数据结构**
- 是一个block数组

**2. 初始化一条新区块链函数-`NewBlockchain`**
- 定义BlockChain类型的链对象
- 将创世块作为链的第一个数组对象加进去

**3. 向链中添加区块方法-`AddBlock`**
- block对象
- 当前区块的ParentHash，将区块链中的上一个块的Blockhash赋值给当前区块的ParentHash
- 当前区块的块Number，在区块链中的上一个区块的Number基础上+1
- 返回block
### 1. blockchain的数据结构
---
是一个block数组
```
//blockchain结构
//是一个block数组
type BlockChain struct {
	blocks []*Block
}

```
### 2. 初始化一条新区块链函数-`NewBlockchain`
---
```
//启动一条区块链
func NewBlockchain() *BlockChain {
	return &BlockChain{[]*Block{NewGenesisBlock()}}
}
```
### 3. 向链中添加区块方法-`AddBlock`
---
向链中添加区块
```
//向区块链中添加区块
//
func (bc *BlockChain) AddBlock(header *Header, body *Body) {
	prevBlock := bc.blocks[len(bc.blocks)-1]
	header.ParentHash = prevBlock.header.Blockhash
	header.Number = prevBlock.header.Number + 1
	newBlock := NewBlock(header, body)
	bc.blocks = append(bc.blocks, newBlock)

}
```
---
## *main函数
---
`main.go`
主要实现功能：
- 添加两个区块
- 打印区块链中的区块信息
* 注： 这里的log用的是自己内部使用的一个包。可以用别的log包替换，不影响，只是为了规范输出的日志内容。
```
package main

import (
	mylog "mylog2"
	"time"
)

var Logger *mylog.SimpleLogger

//注释1
func main() {
	Logger = mylog.NewSimpleLogger("XChain-Go")
	Logger.Infoln("版本信息GitVersion:", GitVersion, ",BuildDate:", BuildDate)
	//初始化一条链
	bc := NewBlockchain()
	//构造两个区块
	header1 := &Header{}
	header2 := &Header{}
	body1 := &Body{}
	body2 := &Body{}
	header1.Extradata = []byte("sender 1btc to alice")
	header2.Extradata = []byte("sender 1btc to bob")
	//添加两个区块
	bc.AddBlock(header1, body1)
	time.Sleep(time.Second)
	bc.AddBlock(header2, body2)
	//打印链中的区块信息
	for _, block := range bc.blocks {
		Logger.Infoln("------------Block", block.header.Number, "--------------------")
		Logger.Infoln("prevhash:", block.header.ParentHash)
		Logger.Infoln("data:", string(block.header.Extradata))
		Logger.Infoln("Blockhash: ", block.header.Blockhash)
		Logger.Infoln("blocknumber: ", block.header.Number)
		Logger.Infoln("Timestamp： ", timeformat(block.header.Timestamp))
	}
}
func timeformat(unixtimestamp int64) string {
	time := time.Unix(unixtimestamp, 0)
	timeformat := time.Format("Mon Jan _2 15:04:05 MST 2006")
	return timeformat
}
```
### cli
（cli的方式去打印链的内容，应该是需要数据持久化去实现的，还没有尝试成功，后面通过web的方式去实现）
```
package main

import (
	"flag"
	"fmt"
	"math/rand"
	"os"
	"time"
)

//负责处理命令行参数的CLI
type CLI struct {
	//对象是链
	bc *BlockChain
}

//方法说明
func (cli *CLI) printusage() {
	fmt.Println("usage:")
	fmt.Println(" ./xchain printblockchain                   -- print all block in the blockchain")
	fmt.Println(" ./xchain addblock -data 'Block data'       -- add a new block into the blockchain")

}

//添加区块
func (cli *CLI) addBlock(extradata string) {
	header := &Header{}
	body := &Body{}
	header.Extradata = []byte(extradata)
	cli.bc.AddBlock(header, body)
}

//打印区块链内容
func (cli *CLI) printblockchain() {
	for _, block := range cli.bc.blocks {
		Logger.Infoln("------------Block", block.header.Number, "--------------------")
		Logger.Infoln("prevhash:", block.header.ParentHash)
		Logger.Infoln("Delegator:", block.header.Delegator)
		Logger.Infoln("data:", string(block.header.Extradata))
		Logger.Infoln("Blockhash: ", block.header.Blockhash)
		Logger.Infoln("blocknumber: ", block.header.Number)
		Logger.Infoln("Timestamp： ", TimeFormat(block.header.Timestamp))
		fmt.Println()
	}
}

//打印区块链内容
func (cli *CLI) startServer() {
	CreateNode()
	fmt.Println(NodeArr)
	Vote()
	nodes := SortNodes()
	fmt.Println(nodes)
	//初始化一条链

	// 添加区块
	nodesNum := len(nodes)
	for i := 0; i < nodesNum; i++ {

		// 构造区块
		header := &Header{}
		// header2 := &Header{}
		body := &Body{}
		// body2 := &Body{}
		header.Extradata = []byte("sender 1btc to alice")
		header.Delegator = nodes[i].Name
		cli.bc.AddBlock(header, body)
		time.Sleep(time.Second)

	}

	cli.printblockchain()

}

//校验输入的参数是否合法
//如果参数的长度小于2，即参数中只有二进制项目名，没有后面相应的执行的命令及参数，则退出
func (cli *CLI) validateArgs() {
	if len(os.Args) < 2 {
		// fmt.Println(os.Args[:])
		cli.printusage()
		os.Exit(1)
	}
	// fmt.Println(os.Args[:])
}

func (cli *CLI) Run() {
	cli.validateArgs()
	//flag命令进行定义
	printusageCmd := flag.NewFlagSet("printusage", flag.ExitOnError)           //打印用法
	printblockchainCmd := flag.NewFlagSet("printblockchain", flag.ExitOnError) //打印区块链
	addblockCmd := flag.NewFlagSet("addblock", flag.ExitOnError)               //添加区块
	addblockData := addblockCmd.String("data", "", "Block ExtraData")          //addblockData定义一个string的flag，来对data的参数进行判断。得到的是一个指针对象
	startServerCmd := flag.NewFlagSet("startServer", flag.ExitOnError)

	//判断传入的命令参数内容
	//参数内容中，第一个字符为二进制项目名，第二个字符开始内容为实际的输入。
	//第二个字符为实际想执行的命令字段，第三个字符为要传入的参数
	//判断第二个参数的内容，来执行printblockchain、addblock、printusage的对应操作
	switch os.Args[1] {
	case "printusage":
		err := printusageCmd.Parse(os.Args[2:])
		if err != nil {
			Logger.Errorln(err)
		}

	case "printblockchain":
		err := printblockchainCmd.Parse(os.Args[2:])
		if err != nil {
			Logger.Errorln(err)
		}

	case "addblock":
		err := addblockCmd.Parse(os.Args[2:])
		if err != nil {
			Logger.Errorln(err)
		}

	case "startServer":
		err := startServerCmd.Parse(os.Args[2:])
		if err != nil {
			Logger.Errorln(err)
		}

	default:
		//非零为错误退出
		cli.printusage()
		os.Exit(1)
	}

	//初始化启动的时候，打印usage
	if printusageCmd.Parsed() {
		cli.printusage()
	}

	//命令行信息读取结束，则执行打印区块链的操作
	//todo:完成数据持久化后，从数据库读取链的所有内容
	if printblockchainCmd.Parsed() {
		cli.printblockchain()
	}

	//判断addblock命令传入的参数，添加新区块
	//todo：完成数据持久化后，将添加的块插入数据库
	if addblockCmd.Parsed() {
		//判断输入的data参数的值是否为空
		if *addblockData == "" {
			// fmt.Println(*addblockData)
			cli.printusage()
			os.Exit(1)
		}
		fmt.Println(*addblockData)
		cli.addBlock(*addblockData)
		cli.printblockchain() //打印一下添加区块后的链信息，目前没加数据持久化，所以只能打印一次。
	}

	if startServerCmd.Parsed() {
		cli.startServer()
	}

}

// 创建节点
func CreateNode() {
	for i := 0; i < 10; i++ {
		name := RandStringBytes(AddressLength)
		NodeArr[i] = Node{name, 0}
	}
}

func RandStringBytes(n int) Address {
	letterBytes := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	var b Address
	for i := range b {
		b[i] = letterBytes[rand.Intn(len(letterBytes))]
	}
	return b
}

//简单模拟投票
func Vote() {
	for i := 0; i < 10; i++ {
		rand.Seed(time.Now().UnixNano())
		vote := rand.Intn(10) + 1
		NodeArr[i].Votes = vote
	}
}

//选出票数最多的前3位
func SortNodes() []Node {
	n := NodeArr
	for i := 0; i < len(n); i++ {
		for j := 0; j < len(n)-1; j++ {
			if n[j].Votes < n[j+1].Votes {
				n[j], n[j+1] = n[j+1], n[j]
			}
		}
	}
	return n[:3]
}

```

## * 数据持久化--使用leveldb
> go语言leveldb参考链接：https://www.jianshu.com/p/69f0219f3700

链的数据结构改变
我们需要与数据库存储有关，所以新增一个db字段。
存储的内容不希望再存整个block，而是block的hash，所以将原字段block修改为headhash（暂定）

### 数据结构
```
//blockchain结构
//补充db字段,存储的时候只存block的hash
type BlockChain struct {
	headhash []byte
	db         *ethdb.Database
}
```

### 更新addblock方法，补充存储数据的过程

```
```


## 状态树存储
> 这部分的具体内容主要是在以太坊代码的/core/state/statedb.go里，updateStateObject，getStateObject，deleteStateObject这些方法。
1.然后调用的trie的存储就是/trie/trie.go里的TryUpdate方法。
2.这个TryUpdate方法里的insert方法，会将收到的addr[:]进行hex编码，形成树